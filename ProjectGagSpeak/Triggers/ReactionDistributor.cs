using CkCommons.Helpers;
using Dalamud.Game.Text.SeStringHandling;
using GagSpeak.Interop;
using GagSpeak.Kinksters;
using GagSpeak.MufflerCore;
using GagSpeak.PlayerClient;
using GagSpeak.State.Handlers;
using GagSpeak.State.Listeners;
using GagSpeak.State.Managers;
using GagSpeak.State.Models;
using GagSpeak.Utils;
using GagSpeak.WebAPI;
using GagspeakAPI.Data;
using GagspeakAPI.Extensions;
using OtterGui.Extensions;

namespace GagSpeak.Services;

/// <summary>
///     Performs reactions from InvokableGsActions. <para />
///     These are generated by triggers and aliases. <para />
///     Async reaction types are monitored to ensure duplicates are not ran if processing already.
/// </summary>
/// <remarks> Limiters can be imposed for excessive use of async operations. </remarks>
public class ReactionDistributor
{
    private readonly ILogger<ReactionDistributor> _logger;
    private readonly PiShockProvider _shockies;
    private readonly GagRestrictionManager _gags;
    private readonly RestrictionManager _restrictions;
    private readonly RestraintManager _restraints;
    private readonly PuppeteerManager _puppeteer;
    private readonly BuzzToyManager _toys;
    private readonly MoodleHandler _moodles;
    private readonly SelfBondageService _selfBondage;

    public ReactionDistributor(
        ILogger<ReactionDistributor> logger,
        PiShockProvider shockies,
        GagRestrictionManager gags,
        RestrictionManager restrictions,
        RestraintManager restraints,
        PuppeteerManager puppeteer,
        BuzzToyManager toys,
        MoodleHandler moodles,
        SelfBondageService selfBondage)
    {
        _logger = logger;
        _shockies = shockies;
        _gags = gags;
        _restrictions = restrictions;
        _restraints = restraints;
        _puppeteer = puppeteer;
        _toys = toys;
        _moodles = moodles;
        _selfBondage = selfBondage;
    }

    #region Invocations
    public bool HandleAction(InvokableGsAction action, string? enactor = null) => action switch
    {
        TextAction ta       => TextReaction(ta, enactor),
        MoodleAction ma     => MoodleReaction(ma, enactor),
        PiShockAction ps    => PiShockReaction(ps, enactor),
        SexToyAction sta    => SexToyReaction(sta, enactor),
        _ => false
    };

    public async Task<bool> HandleActionAsync(InvokableGsAction action, string? enactor = null) => action switch
    {
        TextAction ta => TextReaction(ta, enactor),
        GagAction ga => await DoGagAction(ga, enactor),
        RestrictionAction rsa => await DoRestrictionAction(rsa, enactor),
        RestraintAction rta => await DoRestraintAction(rta, enactor),
        MoodleAction ma => MoodleReaction(ma, enactor),
        PiShockAction ps => PiShockReaction(ps, enactor),
        SexToyAction sta => SexToyReaction(sta, enactor),
        _ => false
    };

    // Run all actions together.
    public bool HandleActions(IEnumerable<InvokableGsAction> actions, string? enactor = null)
    {
        var anySuccess = false;
        foreach (var action in actions)
        {
            var result = HandleAction(action, enactor);
            if (result && !anySuccess)
                anySuccess = true;
        }
        return anySuccess;
    }

    public async Task<bool> HandleActionsAsync(IEnumerable<InvokableGsAction> actions, string? enactor = null)
    {
        var anySuccess = false;
        foreach (var action in actions)
        {
            var result = await HandleActionAsync(action, enactor);
            if (result && !anySuccess)
                anySuccess = true;
        }
        return anySuccess;
    }

    // Unique logic spesific to Alias text reactions.
    /// <summary>
    ///     Determines if the message meets the criteria for the sender.
    /// </summary>
    /// <param name="context"> The context of the puppeteer message, including permissions and sender info. </param>
    /// <param name="message"> The message to evaluate a command, EXCLUDING any trigger words. </param>
    public void HandlePuppeteeredText(PuppetMsgContext context, SeString message)
    {
        // ALL permission (non-emote)
        if (context.PuppetPerms.HasAny(PuppetPerms.All) && !IsEmoteMatch(message, out var _))
        {
            _logger.LogDebug($"Puppeteered by {context.DisplayName} with an [ALL] message.", LoggerType.Puppeteer);
            ChatService.EnqueueMessage($"/{message.TextValue}");
            IncrementStats(context, PuppetPerms.All);
            return;
        }

        // EMOTES
        if (context.PuppetPerms.HasAny(PuppetPerms.Emotes) && IsEmoteMatch(message, out var emoteRow))
        {
            _logger.LogDebug($"Puppeteered by {context.DisplayName} with an [EMOTE] message.", LoggerType.Puppeteer);
            ChatService.EnqueueMessage($"/{message.TextValue}");
            IncrementStats(context, PuppetPerms.Emotes, emoteRow);
            return;
        }

        // SIT / CPOSE
        if (context.PuppetPerms.HasAny(PuppetPerms.Sit))
        {
            // Match SIT emotes (50, 52)
            var sitEmote = EmoteEx.SittingEmotes().FirstOrDefault(e => message.TextValue.Contains(e.Name.Replace(" ", "").ToLower()));
            if (sitEmote.RowId is 50 or 52)
            {
                _logger.LogDebug($"Puppeteered by {context.DisplayName} with an [SIT] message.", LoggerType.Puppeteer);
                ChatService.EnqueueMessage($"/{message.TextValue}");
                IncrementStats(context, PuppetPerms.Sit, sitEmote.RowId);
                return;
            }
            // Match CPOSE emotes (90)
            if (EmoteService.ValidLightEmoteCache.Where(e => e.RowId == 90).Any(e => message.TextValue.Contains(e.Name.Replace(" ", "").ToLower())))
            {
                _logger.LogDebug($"Puppeteered by {context.DisplayName} with a [CPOSE] message.", LoggerType.Puppeteer);
                ChatService.EnqueueMessage($"/{message.TextValue}");
                IncrementStats(context, PuppetPerms.Sit, 90);
            }
        }

        // --- Local helper to check for emote match ---
        bool IsEmoteMatch(SeString msg, out uint rowId)
        {
            var emote = EmoteService.ValidLightEmoteCache.FirstOrDefault(e => e.EmoteCommands.Any(c => string.Equals(msg.TextValue, c.Replace(" ", ""), StringComparison.OrdinalIgnoreCase)));
            rowId = !string.IsNullOrWhiteSpace(emote.Name) ? emote.RowId : uint.MaxValue;
            return rowId != uint.MaxValue;
        }
    }

    /// <summary>
    ///     Respective for PuppeteerOrder results only.
    /// </summary>
    public void IncrementStats(PuppetMsgContext context, PuppetPerms stat, uint emoteRow = uint.MaxValue)
    {
        // Trigger regardless
        GagspeakEventManager.AchievementEvent(UnlocksEvent.OrderRecieved, context.UID ?? string.Empty, stat, emoteRow);

        // No need to do stats if the UID is null or the data is not found
        if (context.UID is null)
            return;
        if (!_puppeteer.Puppeteers.TryGetValue(context.UID, out var data))
            return;

        data.OrdersRecieved++;
        switch (stat)
        {
            case PuppetPerms.Alias: data.AliasOrders++; break;
            case PuppetPerms.Emotes: data.EmoteOrders++; break;
            case PuppetPerms.Sit: data.SitOrders++; break;
            case PuppetPerms.All: data.OtherOrders++; break;
        }
        // Save after incrementing
        _puppeteer.Save();
    }

    #endregion Invocations

    #region Reaction Logic
    // Unique logic spesific to Non-Trigger logic, performed by aliases.

    // Can happen from anyone, player or Kinkster. (Might want to include nameworld or something?)
    private bool TextReaction(TextAction act, string? enactorUid = null)
    {
        // construct the new SeString to send.
        var remainingMessage = new SeString().Append(act.OutputCommand);
        remainingMessage = remainingMessage.ConvertSquareToAngleBrackets();
        if (remainingMessage.TextValue.IsNullOrEmpty())
            return false;

        _logger.LogInformation("Text Action is being executed.", LoggerType.Triggers);
        ChatService.EnqueueMessage($"/{remainingMessage.TextValue}");
        return true;
    }

    private async Task<bool> DoGagAction(GagAction act, string? enactor = null)
    {
        if (_gags.ServerGagData is not { } gagData)
            return false;

        var layerIdx = act.LayerIdx; // Should be -1 for wildcard.
        if (act.NewState is NewState.Enabled)
        {
            if (layerIdx is -1)
                layerIdx = gagData.FindFirstUnused();
            // If still -1, none was found.
            if (layerIdx == -1)
                return false;

            _logger.LogInformation($"Applying [{act.GagType}] to layer {layerIdx}", LoggerType.Triggers | LoggerType.Gags);
            var gagSlot = gagData.GagSlots[layerIdx] with
            {
                GagItem = act.GagType,
                Enabler = enactor ?? MainHub.UID
            };
            return await _selfBondage.DoSelfGagResult(layerIdx, gagSlot, DataUpdateType.Applied).ConfigureAwait(false);
        }
        else if (act.NewState is NewState.Locked)
        {
            if (act.Padlock is Padlocks.None)
                return false;

            // If we have defined a layer idx, look for a gag on that index and return false if none are present or it is locked.
            if (act.LayerIdx != -1)
            {
                if (gagData.GagSlots[act.LayerIdx].IsLocked() || gagData.GagSlots[act.LayerIdx].GagItem is GagType.None)
                    return false;
            }

            // If we have selected a specific gag to lock, look for it, and if none are found, return false.
            if (act.GagType is not GagType.None && gagData.FindOutermostActive(act.GagType) is -1)
                return false;

            // Otherwise, attempt to locate the first lockable gagslot.
            if (layerIdx is -1)
                layerIdx = gagData.FindFirstUnlocked();

            // If still not valid, fail.
            if (layerIdx is -1)
                return false;

            // We have found one to lock. Check what lock we chose, and define accordingly.
            var password = act.Padlock switch
            {
                Padlocks.Password => Generators.GetRandomCharaString(10),
                Padlocks.Combination => Generators.GetRandomIntString(4),
                Padlocks.TimerPassword => Generators.GetRandomCharaString(10),
                _ => string.Empty
            };

            // define a random time between 2 timespan bounds.
            var timer = TimeSpan.Zero;
            if (act.Padlock.IsTimerLock())
            {
                // We have a timer lock. We need to check if we have a normal timer lock or a 5 minutes lock
                if (act.Padlock is Padlocks.FiveMinutes)
                    timer = TimeSpan.FromMinutes(5);
                else
                    timer = Generators.GetRandomTimeSpan(act.LowerBound, act.UpperBound);
            }

            _logger.LogInformation($"Locking [{act.GagType}] with [{act.Padlock}] on layer {layerIdx}", LoggerType.Triggers);
            var gagSlot = gagData.GagSlots[layerIdx] with
            {
                Padlock = act.Padlock,
                Password = password,
                Timer = new DateTimeOffset(DateTime.UtcNow + timer),
                PadlockAssigner = enactor ?? MainHub.UID
            };
            return await _selfBondage.DoSelfGagResult(layerIdx, gagSlot, DataUpdateType.Locked).ConfigureAwait(false);
        }
        else if (act.NewState is NewState.Disabled)
        {
            layerIdx = gagData.FindOutermostActive();

            if (layerIdx is -1)
            {
                _logger.LogWarning($"No active gag found for [{act.GagType}] when attempting to disable.", LoggerType.Triggers);
                return false;
            }

            _logger.LogDebug($"Removing [{gagData.GagSlots[layerIdx].GagItem}] from layer {layerIdx}", LoggerType.Triggers);
            return await _selfBondage.DoSelfGagResult(layerIdx, new ActiveGagSlot(), DataUpdateType.Removed);
        }

        return false;
    }
    private async Task<bool> DoRestrictionAction(RestrictionAction act, string? enactor = null)
    {
        if (_restrictions.ServerRestrictionData is not { } restrictions)
            return false;

        var layerIdx = act.LayerIdx; // Should be -1 for wildcard.
        if (act.NewState is NewState.Enabled)
        {
            if (layerIdx is -1)
                layerIdx = restrictions.Restrictions.IndexOf(x => x.Identifier == Guid.Empty);
            
            // If still -1, none was found.
            if (layerIdx is -1 || restrictions.Restrictions[layerIdx].IsLocked() || !restrictions.Restrictions[layerIdx].CanApply())
                return false;

            _logger.LogInformation($"Applying restriction [{act.RestrictionId}] to layer {layerIdx}", LoggerType.Triggers);
            var itemSlot = restrictions.Restrictions[layerIdx] with
            {
                Identifier = act.RestrictionId,
                Enabler = enactor ?? MainHub.UID
            };
            return await _selfBondage.DoSelfBindResult(layerIdx, itemSlot, DataUpdateType.Applied).ConfigureAwait(false);
        }
        else if (act.NewState is NewState.Locked)
        {
            layerIdx = act.LayerIdx == -1 ? restrictions.Restrictions.IndexOf(x => x.Identifier != Guid.Empty && x.CanLock()) : act.LayerIdx;

            if (layerIdx is -1 || !restrictions.Restrictions[layerIdx].CanLock() || act.Padlock is Padlocks.None)
                return false;

            var timer = TimeSpan.Zero;
            if (act.Padlock.IsTimerLock())
            {
                // We have a timer lock. We need to check if we have a normal timer lock or a 5 minutes lock
                if (act.Padlock is Padlocks.FiveMinutes)
                    timer = TimeSpan.FromMinutes(5);
                else
                    timer = Generators.GetRandomTimeSpan(act.LowerBound, act.UpperBound);
            }

            _logger.LogInformation($"Locking restriction [{act.RestrictionId}] with [{act.Padlock}] on layer {layerIdx}", LoggerType.Triggers);
            var itemSlot = restrictions.Restrictions[layerIdx] with
            {
                Padlock = act.Padlock,
                Password = act.Padlock switch
                {
                    Padlocks.Password => Generators.GetRandomCharaString(10),
                    Padlocks.Combination => Generators.GetRandomIntString(4),
                    Padlocks.TimerPassword => Generators.GetRandomCharaString(10),
                    _ => string.Empty
                },
                Timer = new DateTimeOffset(DateTime.UtcNow + timer),
                PadlockAssigner = enactor ?? MainHub.UID
            };
            return await _selfBondage.DoSelfBindResult(layerIdx, itemSlot, DataUpdateType.Locked).ConfigureAwait(false);
        }
        else if (act.NewState is NewState.Disabled)
        {
            layerIdx = act.RestrictionId != Guid.Empty
                ? restrictions.Restrictions.IndexOf(x => x.Identifier == act.RestrictionId)
                : restrictions.FindOutermostActiveUnlocked();

            if (layerIdx == -1 || !restrictions.Restrictions[layerIdx].CanRemove())
                return false;

            _logger.LogDebug($"Removing restriction [{restrictions.Restrictions[layerIdx].Identifier}] from layer {layerIdx}", LoggerType.Triggers);
            return await _selfBondage.DoSelfBindResult(layerIdx, new ActiveRestriction(), DataUpdateType.Removed).ConfigureAwait(false);
        }

        return false;
    }

    private async Task<bool> DoRestraintAction(RestraintAction act, string? enactor = null)
    {
        if(_restraints.ServerData is not { } restraint)
            return false;

        if (act.NewState is NewState.Enabled)
        {
            if (!restraint.CanApply() || !_restraints.Storage.Contains(act.RestrictionId))
                return false;

            _logger.LogDebug($"Applying restraint [{act.RestrictionId}]", LoggerType.Triggers);
            var setData = restraint with
            {
                Identifier = act.RestrictionId,
                Enabler = enactor ?? MainHub.UID
            };
            return await _selfBondage.DoSelfRestraintResult(setData, DataUpdateType.Applied).ConfigureAwait(false);
        }
        else if (act.NewState is NewState.Locked)
        {
            if (!restraint.CanLock() || act.Padlock is Padlocks.None)
                return false;

            var timer = TimeSpan.Zero;
            if (act.Padlock.IsTimerLock())
            {
                // We have a timer lock. We need to check if we have a normal timer lock or a 5 minutes lock
                if (act.Padlock is Padlocks.FiveMinutes)
                    timer = TimeSpan.FromMinutes(5);
                else
                    timer = Generators.GetRandomTimeSpan(act.LowerBound, act.UpperBound);
            }

            _logger.LogDebug($"Locking restraint [{act.RestrictionId}] with [{act.Padlock}]", LoggerType.Triggers);
            var setData = restraint with
            {
                Padlock = act.Padlock,
                Password = act.Padlock switch
                {
                    Padlocks.Password => Generators.GetRandomCharaString(10),
                    Padlocks.Combination => Generators.GetRandomIntString(4),
                    Padlocks.TimerPassword => Generators.GetRandomCharaString(10),
                    _ => string.Empty
                },
                Timer = new DateTimeOffset(DateTime.UtcNow + timer),
                PadlockAssigner = enactor ?? MainHub.UID
            };
            return await _selfBondage.DoSelfRestraintResult(setData, DataUpdateType.Locked).ConfigureAwait(false);
        }
        else if (act.NewState is NewState.Disabled)
        {
            if (!restraint.CanRemove())
                return false;
            _logger.LogDebug($"Removing restraint [{act.RestrictionId}]", LoggerType.Triggers);
            return await _selfBondage.DoSelfRestraintResult(new CharaActiveRestraint(), DataUpdateType.Removed).ConfigureAwait(false);
        }

        return false;
    }

    private bool MoodleReaction(MoodleAction act, string? enactor = null)
    {
        if(!IpcCallerMoodles.APIAvailable || act.MoodleItem.Id== Guid.Empty)
        {
            _logger.LogWarning("Moodles not available, cannot execute moodle trigger.");
            return false;
        }

        _logger.LogDebug("Applying a Moodle action to the player.", LoggerType.IpcMoodles);
        _moodles.ApplyMoodle(act.MoodleItem).ConfigureAwait(false);
        return true;
    }

    private bool PiShockReaction(PiShockAction act, string? enactor = null)
    {
        if (ClientData.Globals is not { } perms)
            return false;

        if(string.IsNullOrWhiteSpace(perms.GlobalShockShareCode) || !perms.HasValidShareCode())
        {
            _logger.LogWarning("Can't execute Shock Instruction if none are currently connected!");
            return false;
        }

        // execute the instruction with our global share code.
        _logger.LogInformation("DoPiShock Action is executing instruction based on global sharecode settings!", LoggerType.PiShock);
        var shareCode = perms.GlobalShockShareCode;
        _shockies.ExecuteOperation(shareCode, (int)act.ShockInstruction.OpCode, act.ShockInstruction.Intensity, act.ShockInstruction.Duration);
        return true;
    }

    private bool SexToyReaction(SexToyAction act, string? enactor = null)
    {
        // Nothing atm.
        return true;
    }
    #endregion Reaction Logic
}
